// Package random creates pseudo-random data of various types for use in testing, benchmarking, and production.
//
// Any functions that are NOT safe for concurrent use are labeled as such in their descriptions.
// Any functipons that make heap allocations are similarly indicated. Often there are example
// benchmark output data for relative comparison purposes. Of course, the caller should always
// perform their own testing, benchmarking, and profiling within their own use case to see
// specific and accurate data.

// There are several broad categories of random data that can be generated by random:
//
// Text
//
// Text data are largely represented by the string (utf8 compliant by design in Go) and []byte
// types. They are somewhat interchangeable and have similar standard library methods available.
// The 'text' type is a generic Go (requires v.1.18+) type interface:
//  type text interface {
//  	~string | ~[]byte
//  }
// It is used internally to create generic functions that may accept either string types or []byte
// as input. The type is not exported because of several odd behaviors that prevent a 'perfect'
// generic relationship between the underlying types.

package random

import (
	rand "crypto/rand"
	"io"
)

// Reader is an alias to a global, shared instance of a concurrency safe, cryptographically secure random number generator directly from the Go standard library crypto/rand package.
//
// On Linux, FreeBSD, Dragonfly and Solaris, Reader uses getrandom(2) if available, /dev/urandom otherwise. On OpenBSD and macOS, Reader uses getentropy(2). On other Unix-like systems, Reader reads from /dev/urandom. On Windows systems, Reader uses the RtlGenRandom API. On Wasm, Reader uses the Web Crypto API.
var reader = rand.Reader

// func Reader() io.Reader { return rand.Reader }

// Read is a helper function that reads exactly len(b)
// bytes from rand.Reader into b.
//
// It returns the number of bytes copied and an error
// if fewer bytes were read.
// The error is EOF only if no bytes were read.
// If an EOF happens after reading fewer than min bytes,
// ReadAtLeast returns ErrUnexpectedEOF.
// If len(b) is greater than the length of b, Read returns ErrShortBuffer.
//
// On return, n == len(b) if and only if err == nil.
// If r returns an error having read at least len(buf) bytes, the error is dropped.
// Reference: standard library io.Read
func Read(b []byte) (n int, err error) {
	min := len(b)
	for n < min && err == nil {
		var nn int
		nn, err = reader.Read(b[n:])
		n += nn
	}
	if n >= min {
		err = nil
	} else if n > 0 && err == io.EOF {
		err = io.ErrUnexpectedEOF
	}
	return
	// return io.ReadAtLeast(reader, b, len(b))
}
